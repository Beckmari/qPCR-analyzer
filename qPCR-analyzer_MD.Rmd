---
title: "qPCR Analyzer"
output: html_document
date: "2023-04-29"
version: 0.1
author: "MJB"
---

```{r setup, include=FALSE, echo=FALSE}
#invisible setup
knitr::opts_chunk$set(echo = TRUE)
#packages needed for this script
packages <- c('xlsx', 'dplyr', 'ggplot2', 'ggridges', 'reticulate') #, 'remotes'
  
#install all packages that are not already installed
install.packages(setdiff(packages, rownames(installed.packages())))

#load R packages
library(xlsx, warn.conflicts = FALSE)
library(dplyr, warn.conflicts = FALSE)
library(ggplot2)
library(ggridges)
#library(ridgeline)
library(reticulate)
library(shiny)
 #following Functions are masked: filter, lag, intersect, setdiff, setequal, union (NEEDS TO BE UPDATED!!!)

source('/Users/beckm/Documents/qPCR-analyzer/Script_library.R')
```

```{r data location}
##insert an interactive way to enter the paths!
#enter your data paths:

template_path = '/Users/beckm/OneDrive/Desktop/BA-Projekte/Hevin/qPCR-Template.xlsx' #before you run the script, enter your datapath here
melt_path = '/Users/beckm/OneDrive/Desktop/BA-Projekte/Hevin/Neuer Ordner/qCHS1PrimerConcOptim_chartmelt2.xlsx'
umeltpath <- '/Users/beckm/OneDrive/Desktop/myCSV(1).csv'

#dataimport
meltcomp <- read.xlsx(melt_path, 1)

```

```{r data prep}
#prepare melting data for meltcurve plot

#first and last line of data
lstart <- which(meltcomp == 'Derivation')
lend <- which(meltcomp == 'G12')

#extract data
meltraw <- slice(meltcomp, lstart:lend)

#set row and columnnames
meltraw <- data.frame(meltraw, row.names = 1)
meltraw <- data.frame(t(meltraw))
meltraw <- data.frame(meltraw, row.names = 1)
rnmr <- row.names(meltraw)
meltraw <- apply(meltraw, 2, function(x) as.numeric(as.character(x)))
meltraw <- data.frame(meltraw)
meltraw <- meltraw %>% slice(which(row_number() %% 5 == 1))

#read and prepare umelt data
umelt <- read.csv(umeltpath) #umeltpath definieren
umelt <- cbind.data.frame(umelt$uMelt, umelt$All.Rights.Reserved) 
names(umelt) <- umelt[1,]
umelt <- umelt[-1,]
umelt <- apply(umelt, 2, function(x) as.numeric(as.character(x)))
#code schreiben, für umelt auflösung
umelt <- data.frame(umelt)
umelt <- umelt %>% slice(which(row_number() %% 2 == 1))
umelt <- head(umelt, - 11) ##eventuell besserer weg nach dem maximum in meltraw zu suchen und diesen wert zu benutzen
```

```{r melt curve correlation, echo=FALSE}
k <- 1
coeff <- c()
#correlation analysis of meltcurve against umelt data
for (i in colnames(meltraw)) {
  a <- cor(umelt$X..dF.dT, meltraw[[i]])
  coeff <- c(coeff, a)
  k == k + 1
}
#print(coeff)
#coeff output filtern für threshold

#outouts von cor() und cor.test() anschauen was die aussagen und gegebenenfalls besseren test suchen.


```










