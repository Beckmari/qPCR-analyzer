---
title: "qPCR Analyzer"
output: html_document
date: "2023-04-29"
version: 0.1
author: "MJB"
---

```{r setup, include=FALSE, echo=FALSE}
#invisible setup
knitr::opts_chunk$set(echo = TRUE)
#packages needed for this script
packages <- c('xlsx', 'readxl', 'dplyr', 'ggplot2', 'ggridges', 'reticulate', 'svDialogs', 'rapport') #, 'remotes'
  
#install all packages that are not already installed
install.packages(setdiff(packages, rownames(installed.packages())))

#load R packages
library(xlsx, warn.conflicts = FALSE)
library(dplyr, warn.conflicts = FALSE)
library(ggplot2)
library(ggridges)
#library(ridgeline)
library(reticulate)
library(shiny)
library(readxl)
library(svDialogs)
library(rapport)
 #following Functions are masked: filter, lag, intersect, setdiff, setequal, union (NEEDS TO BE UPDATED!!!)

source('Script_library.R')
rm(packages)
```

```{r data location}
##insert an interactive way to enter the paths!
#enter your data paths:

template_path <- 'qPCR-Template.xlsx' #before you run the script, enter your datapath here
melt_path <- 'C:/Users/beckm/OneDrive/Desktop/BA-Projekte/Hevin/230504 P= P4 Primereffizienzen/chartmelt.xlsx'
umeltpath <- '/Users/beckm/OneDrive/Desktop/myCSV(1).csv'
ctpath <- '/Users/beckm/OneDrive/Desktop/BA-Projekte/Hevin/230504 P= P4 Primereffizienzen/amplictvalue.xlsx'

```

```{r template prep, echo=FALSE}
#96-well empty template
plate <- c()
for(i in 1:8) {
  for(k in 1:12){
    result <- switch (i,
      "1" = paste('A', k, sep = ''),
      "2" = paste('B', k, sep = ''),
      "3" = paste('C', k, sep = ''),
      "4" = paste('D', k, sep = ''),
      "5" = paste('E', k, sep = ''),
      "6" = paste('F', k, sep = ''),
      "7" = paste('G', k, sep = ''),
      "8" = paste('H', k, sep = '')
    )
    
    plate <- c(plate, result)
  }
}
rm(result, i, k)

#experimental template import
template <- read.xlsx(template_path, 1, header = FALSE)
rm(template_path)
template <- as.vector(t(template))
template <- data.frame(cbind(plate, template))
template <- na.omit(template)
#template <- as.vector(t(template))
temp_id <- unique(template)
temp_id <- temp_id[!is.na(temp_id)]

```

```{r data prep}
#prepare melting data for meltcurve analysis

#dataimport
meltcomp <- read.xlsx(melt_path, 1)
rm(melt_path)

#first and last line of data
lstart <- which(meltcomp == 'Derivation')
lend <- lstart + 97

#extract data
meltraw <- slice(meltcomp, lstart:lend)
rm(lstart, lend, meltcomp)

#set row and columnnames
meltraw <- data.frame(meltraw, row.names = 1)
meltraw <- data.frame(t(meltraw))
meltraw <- data.frame(meltraw, row.names = 1)
meltraw <- apply(meltraw, 2, function(x) as.numeric(as.character(x)))
meltraw <- data.frame(meltraw)
meltraw <- meltraw %>% slice(which(row_number() %% 5 == 1))

#read and prepare umelt data
umelt <- read.csv(umeltpath) #umeltpath definieren
rm(umeltpath)
umelt <- cbind.data.frame(umelt$uMelt, umelt$All.Rights.Reserved) 
names(umelt) <- umelt[1,]
umelt <- umelt[-1,]
umelt <- apply(umelt, 2, function(x) as.numeric(as.character(x)))

#code schreiben, für umelt auflösung
umelt <- data.frame(umelt)
umelt <- umelt %>% slice(which(row_number() %% 2 == 1))
umelt <- head(umelt, - 11) ##eventuell besserer weg nach dem maximum in meltraw zu suchen und diesen wert zu benutzen
```

```{r melt curve correlation, echo=FALSE}
#maximal experimental
coeff <- c()
coeff_stats <- c()
#correlation analysis of meltcurve against umelt data
for (i in colnames(meltraw)) {
  a <- cor(umelt$X..dF.dT, meltraw[[i]])
  b <- cor.test(umelt$X..dF.dT, meltraw[[i]])
  coeff <- c(coeff, a)
  coeff_stats <- c(coeff_stats, b)
  
}
rm(a, i)
#print(coeff)
#coeff output filtern für threshold

#outouts von cor() und cor.test() anschauen was die aussagen und gegebenenfalls besseren test suchen.
samplecorr <- data.frame(cbind(template, coeff))
meltcorrplot <- plot(1:84, samplecorr$coeff, main = "Experimental correlation of melting curves! DO NOT USE!!!")

```

```{r CT Analysis}
#import CT values
ctvalues <- read.xlsx(ctpath, 1)
lstart <- which(ctvalues == "Well")
lend <- lstart + 97
ctvalues <- slice(ctvalues, lstart:lend)
names(ctvalues) <- ctvalues[1,]
ctvalues <- ctvalues[-1,]
#extract data with sample type unknown
ctvaluesnew <- which(ctvalues$`Sample type` == "Unknown")
ctvaluesnew <- ctvalues[ctvaluesnew, ]
ctvaluesnew <- transform(ctvaluesnew, Ct = as.numeric(Ct))
ctstat <- c()
ctrows <- nrow(ctvaluesnew)
#extract data and test for NA
for (n in seq(from = 1, to = ctrows , by = 3)) {
  a <- ctvaluesnew$Sample.name[n]
  nend <- n+2
  #jump over triplicate if one replicate is NA
  if (!is.na(ctvaluesnew$Ct[n])){
    i <- n+1
    if (!is.na(ctvaluesnew$Ct[i])){
      if (!is.na(ctvaluesnew$Ct[nend])){
        
        b <- ctvaluesnew$Ct[n:nend]
        k <- mean(ctvaluesnew$Ct[n:nend])
        k_sd <- sd(ctvaluesnew$Ct[n:nend])
        k_var <- var(ctvaluesnew$Ct[n:nend])
        result <- c(a, b, k, k_sd, k_var)
        ctstat <- cbind(ctstat, result)
        rm(result)
      }
    }
  }
}
rm(ctrows, a, b, k, k_sd, k_var, n, i, nend)
ctstat <- data.frame(t(ctstat))
#extract CHS1 data
#develop method for random extraction 
#ctCHS1 <- grepl("CHS",ctstat$X1,fixed = TRUE)
ctCHS1 <- c()
ctRPS6 <- c()
for (n in 1:nrow(ctstat)) {
  if (grepl("CHS",ctstat$X1[n],fixed = TRUE) == TRUE) {
    ctCHS1 <- rbind(ctCHS1, ctstat[n,])
  } else if (grepl("RpS", ctstat$X1[n], fixed = TRUE) == TRUE) {
    ctRPS6 <- rbind(ctRPS6, ctstat[n,])
  }
}
ctRPS6 <- transform(ctRPS6, X2 = as.numeric(X2), 
                    X3 = as.numeric(X3), X4 = as.numeric(X4), 
                    X5 = as.numeric(X5), X6 = as.numeric(X6), 
                    X7 = as.numeric(X7))

ctCHS1 <- transform(ctCHS1, X2 = as.numeric(X2), 
                    X3 = as.numeric(X3), X4 = as.numeric(X4), 
                    X5 = as.numeric(X5), X6 = as.numeric(X6), 
                    X7 = as.numeric(X7))


#calulate CT Values
deltaCT <- dCt_calc(ctCHS1$X5, ctRPS6$X5)
ctCHS1 <- cbind(ctCHS1, deltaCT)

#group biological Replicates
for (n in 1:nrow(ctCHS1)) {
  if (grepl("P0",ctCHS1$X1[n],fixed = TRUE) == TRUE) {
    P0 <- rbind(P0, ctCHS1[n,])
  } else if (grepl("P4", ctCHS1$X1[n], fixed = TRUE) == TRUE) {
    ctRPS6 <- rbind(ctRPS6, ctCHS1[n,])
  }
}


```
